---
import BaseLayout from '../../layouts/BaseLayout.astro';
import FileIcon from '../../components/FileIcon.astro';
import FolderIcon from '../../components/FolderIcon.astro';
import ChevronRightIcon from '../../components/ChevronRightIcon.astro';
import { getCollection } from 'astro:content';

const slugifySegment = (value: string) =>
  value
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');

const formatYMD = (d: Date) => {
  const local = new Date(d.getTime() - d.getTimezoneOffset() * 60000);
  return local.toISOString().slice(0, 10);
};

export async function getStaticPaths() {
  const posts = await getCollection('blog');
  const slugifySegmentLocal = (value: string) =>
    value
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '');
  const meta = posts.map((entry) => {
    const rawPath = entry.id.replace(/^blog\//, '').replace(/\.md$/, '');
    const rawSegments = rawPath.split('/');
    const slugSegments = rawSegments.map(slugifySegmentLocal);
    const slugPath = slugSegments.join('/');
    return { slugSegments, slugPath };
  });

  const folderSlugs = new Set<string>();
  meta.forEach((item) => {
    for (let i = 1; i < item.slugSegments.length; i++) {
      folderSlugs.add(item.slugSegments.slice(0, i).join('/'));
    }
  });

  const postPaths = meta.map((item) => ({
    params: { segments: item.slugPath },
  }));
  const folderPaths = Array.from(folderSlugs).map((slug) => ({
    params: { segments: slug },
  }));
  return [...postPaths, ...folderPaths];
}

const posts = await getCollection('blog');
const meta = posts.map((entry) => {
  const rawPath = entry.id.replace(/^blog\//, '').replace(/\.md$/, '');
  const rawSegments = rawPath.split('/');
  const slugSegments = rawSegments.map(slugifySegment);
  const slugPath = slugSegments.join('/');
  return { entry, rawSegments, slugSegments, slugPath };
});

const segmentsRaw = Astro.params.segments;
const segments = typeof segmentsRaw === 'string'
  ? segmentsRaw.split('/').filter(Boolean)
  : Array.isArray(segmentsRaw)
    ? segmentsRaw
    : [];

const slugPath = segments.join('/');
const postMeta = meta.find((item) => item.slugPath === slugPath) ?? null;
const Content = postMeta ? (await postMeta.entry.render()).Content : null;

const latestDateFor = (slugPrefix: string) => {
  const prefix = slugPrefix ? `${slugPrefix}/` : '';
  let latest: Date | null = null;
  meta.forEach((item) => {
    if (!prefix || item.slugPath.startsWith(prefix)) {
      latest = !latest || item.entry.data.date > latest ? item.entry.data.date : latest;
    }
  });
  return latest ? formatYMD(latest) : null;
};

const listAtPath = (slugSegments: string[]) => {
  const folderMap = new Map<string, { slug: string; label: string; total: number }>();
  const files: typeof meta[number][] = [];

  meta.forEach((item) => {
    if (!slugSegments.every((seg, idx) => item.slugSegments[idx] === seg)) return;
    if (item.slugSegments.length === slugSegments.length) return;

    if (item.slugSegments.length === slugSegments.length + 1) {
      files.push(item);
      return;
    }

    const childSlug = item.slugSegments[slugSegments.length];
    if (!folderMap.has(childSlug)) {
      const slug = [...slugSegments, childSlug].join('/');
      folderMap.set(childSlug, {
        slug,
        label: item.rawSegments[slugSegments.length] ?? childSlug,
        total: meta.filter((m) => m.slugPath.startsWith(`${slug}/`) || m.slugPath === slug).length,
      });
    }
  });

  files.sort((a, b) =>
    a.entry.data.title.localeCompare(b.entry.data.title, 'en', { sensitivity: 'base' }),
  );
  const folders = Array.from(folderMap.values()).sort((a, b) =>
    a.label.localeCompare(b.label, 'en', { sensitivity: 'base' }),
  );

  return { folders, files };
};

const folderSegments = postMeta ? segments.slice(0, -1) : segments;
const { folders, files } = postMeta ? { folders: [], files: [] } : listAtPath(segments);

const folderLabelMap = new Map<string, string>();
meta.forEach((item) => {
  item.slugSegments.forEach((_, idx) => {
    if (idx === 0) return;
    const slug = item.slugSegments.slice(0, idx).join('/');
    const label = item.rawSegments[idx - 1];
    if (label && !folderLabelMap.has(slug)) {
      folderLabelMap.set(slug, label);
    }
  });
});
const heading =
  folderSegments.length === 0
    ? 'Blog'
    : folderLabelMap.get(folderSegments.join('/')) ?? folderSegments[folderSegments.length - 1];

const folderCrumbs = [
  { label: 'Home', href: '/' },
  { label: 'Blog', href: '/blog' },
  ...folderSegments.map((segment, idx) => {
    const slug = folderSegments.slice(0, idx + 1).join('/');
    const label = folderLabelMap.get(slug) ?? segment;
    const href = `/blog/${slug}/`;
    return { label, href };
  }),
];

const breadcrumbs = postMeta
  ? [...folderCrumbs, { label: postMeta.entry.data.title }]
  : folderCrumbs.map((crumb, idx) =>
      idx === folderCrumbs.length - 1 ? { ...crumb, href: undefined } : crumb,
    );
---

<BaseLayout
  title={postMeta ? `${postMeta.entry.data.title} | Blog` : `${heading} | Blog`}
  breadcrumbs={breadcrumbs}
  pageId="page-blog"
>
  {
    postMeta ? (
      <main class="post-page">
        <section class="post-hero">
          <h1 class="post-title-hero">{postMeta.entry.data.title}</h1>
          <div class="post-meta">
            <p class="post-date">{formatYMD(postMeta.entry.data.date)}</p>
            {postMeta.entry.data.tags && postMeta.entry.data.tags.length > 0 && (
              <div class="tag-row">
                {postMeta.entry.data.tags.map((tag) => (
                  <span class="tag">{tag}</span>
                ))}
              </div>
            )}
          </div>
        </section>

        <article class="prose-content">
          {Content && <Content />}
        </article>
      </main>
    ) : (
      <>
        <section class="hero">
          <h1 class="caps">{heading}</h1>
        </section>

        <section class="entry-list">
          {folders.map((folder) => (
            <a class="entry-card folder" href={`/blog/${folder.slug}/`}>
              <span class="entry-icon" aria-hidden="true"><FolderIcon /></span>
              <div class="entry-body">
                <div class="entry-title">{folder.label}</div>
              </div>
              <div class="entry-meta">{folder.total} â€º</div>
            </a>
          ))}

          {files.map((entry) => (
            <a class="entry-card file" href={`/blog/${entry.slugPath}/`}>
              <span class="entry-icon" aria-hidden="true"><FileIcon /></span>
              <div class="entry-body">
                <div class="entry-title">{entry.entry.data.title}</div>
              </div>
              <div class="entry-meta">{formatYMD(entry.entry.data.date)}</div>
            </a>
          ))}
        </section>
      </>
    )
  }
</BaseLayout>

<style>
  .post-page {
    display: flex;
    flex-direction: column;
    gap: 1.25rem;
  }

  .post-hero {
    display: flex;
    flex-direction: column;
    gap: 0.4rem;
    padding: 0;
  }

  .post-title-hero {
    margin: 0;
    font-size: clamp(2.5rem, 6vw, 3.75rem);
    letter-spacing: 0.08em;
    text-transform: none;
    line-height: 1.1;
    font-family: 'Share Tech', 'Geist Mono', 'FiraCode', 'Geist', 'Inter', system-ui, -apple-system, sans-serif;
    padding: var(--card-padding) 0;
  }

  .post-meta {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 1rem;
    flex-wrap: wrap;
    padding: 0 0 var(--card-padding);
    border-bottom: 1px solid var(--border);
  }

  .post-date {
    margin: 0;
    color: var(--muted);
    font-size: 0.95rem;
  }

  .tag-row {
    display: flex;
    gap: 0.4rem;
    flex-wrap: wrap;
    justify-content: flex-end;
    align-items: center;
    margin: 0;
    flex: 1 1 auto;
  }

  .tag {
    padding: 0.2rem 0.6rem;
    border-radius: var(--radius-sm);
    border: 1px solid var(--border);
    color: var(--muted);
    font-size: 0.85rem;
  }

  .prose-content {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  .prose-content :global(p) {
    margin: 0 0 1rem;
    line-height: 1.7;
  }

  .prose-content :global(a) {
    color: var(--accent-highlight);
  }
</style>
